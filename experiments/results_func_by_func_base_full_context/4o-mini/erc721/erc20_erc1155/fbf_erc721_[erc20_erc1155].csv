run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,848.8449192047119,45,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition forall (address operator) operator == _operator || _operatorApprovals[msg.sender][operator] == __verifier_old_bool(_operatorApprovals[msg.sender][operator])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_dLN0tAx8VMffkZmC0mODYXWj', 'thread_3grXoYGbYEWSCPVmwIKrDDNU', 'thread_etRDyC6jeAqvlkIL6Lq7ORKx', 'thread_prxy7k1RcilQ0ie0iOAtxzUB', 'thread_oFl5OOBDebG6XDu6c11174Vm', 'thread_FfcPjld4sdGySGNg4RfukAJH', 'thread_jRUjE1Gu8PgX5WeD071PVAJg', 'thread_lTSwvs6wYF267uWAm5kWbJoJ', 'thread_he9H8pU2X6JuYRWD0gLoZCpF']"
2,1051.3965690135956,46,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition forall (address operator) operator == _operator || _operatorApprovals[msg.sender][operator] == __verifier_old_bool(_operatorApprovals[msg.sender][operator])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition _operatorApprovals[_owner][_operator] == approved
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0) || _tokenApprovals[_tokenId] == __verifier_old_address(_tokenApprovals[_tokenId])
    /// @notice postcondition _from == msg.sender || _tokenApprovals[_tokenId] == msg.sender || _from == __verifier_old_address(_from)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_nJbt7VVoci9ovMja65M13pXD', 'thread_6Mv4MeN7YBFaEAKKyJ2jK5CV', 'thread_RXo2AiVPGTJs7G65v8MjBth7', 'thread_M9uvHvQeiHD43M7Guz1Z12f5', 'thread_nFxqpJIfa9iPKr5REPiTArCD', 'thread_QUytXzhe6GcuCNBfMxup3Ibj', 'thread_pWRFFSV3LycbWet65cgB4fQe', 'thread_AZGPfZbjkazPUJyDoxm0KWP6', 'thread_3S35KuxM2q6VdjLj6MmdGSXm']"
3,970.8804965019226,50,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_tokenOwner[_tokenId]) || _from == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_yQUx6nFcNNHmgIqmQF3S1biS', 'thread_D2i7Wj1knXy2pjrL6K1UrBf7', 'thread_joB7ZzpWaCsyw4k1M2Rwj12Z', 'thread_Ldj6Z6TDhxP9HlCD5nx0LcFA', 'thread_lxclf5t6HgpuM7riLQjJBs1L', 'thread_rHC8eOIy6FkwdW3Fz1hMUyHQ', 'thread_DXmfjDZwEhxRRbxwCyGivQZ3', 'thread_yVTCz1SU5qBjNSG3tx722czj', 'thread_Jq3eO0ja3xu5UA3JWb1XpXEV']"
4,599.5120224952698,32,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition forall (address operator) operator == _operator || _operatorApprovals[msg.sender][operator] == __verifier_old_bool(_operatorApprovals[msg.sender][operator])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition __verifier_old_address(_tokenOwner[_tokenId]) == _from
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_nrTmG6t2cbtpdS8TI5IPLFsH', 'thread_bRrg0fRggtRYz7so3K1e9tdc', 'thread_0YbtPMge7dwOzGyoMp1N0qmq', 'thread_qFEzUbheeZC3wAUaLeC0Fw2e', 'thread_FhrXVClRaQJKbig17lh3M4JK', 'thread_ElQEBlHN4nESC0lVeF6p7f7m', 'thread_NLcw10JqCh2UMHrQNtYTMhtW', 'thread_gfRh6hQWjHVJVgnYUqGpitIp', 'thread_mDLErHTlH53w2EEOX3uXfNh9']"
5,693.500771522522,46,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition _operatorApprovals[_owner][_operator] == approved
    /// @notice postcondition approved == __verifier_old_bool(_operatorApprovals[_owner][_operator])
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_tokenOwner[_tokenId]) || _from == _to
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_tokenOwner[_tokenId]) || _tokenOwner[_tokenId] == __verifier_old_address(_from)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_0hH9zDWSvPSKcAp5c4bfDfLf', 'thread_3WUAmA9wiDNuWJ9ytY7KVXKE', 'thread_g2nUVQlYjTfwsQJrZBwieZkM', 'thread_LM7S9xElkNxENwjL7ABY1jpn', 'thread_rU54bhBg93jNEznc4rM7UX2a', 'thread_3oZvF9TUaS92dFPyDbYCa3zi', 'thread_nDRx2K7mYLB6r9zSyJv8btAd', 'thread_Ve0UAiO8LIPPlAT4hONVEM2R', 'thread_qOCUtBoeUdfkeI0CCfYdZRTz']"
6,469.99399876594543,27,True,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _owner == _tokenOwner[_tokenId]
    /// @notice postcondition _tokenId != 0 || _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) != _approved || _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) == address(0) || _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) == _approved || _tokenApprovals[_tokenId] == _approved
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _approved != __verifier_old_bool(_approved)
    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition _operatorApprovals[_owner][_operator] == approved
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition __verifier_old_address(_tokenOwner[_tokenId]) == _from
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_ud0UPoLFryptPHGg3mjVrniL', 'thread_qA1ZmdN8INFcvZGy7ZSIqJqV', 'thread_W2l6tt5DLugRiBThGPTWtvxI', 'thread_lrhbHPHKsMVIzqkfQP03Ngfa', 'thread_LWenFnfbBbN9AxYXPfjbGts4', 'thread_kFQ8UidFKsAplNVswfegYziE', 'thread_BWkutwCQTBAMhxgA7UsKngiO', 'thread_ChXpu9llEoOGyYIkNfMgTFlW', 'thread_45gnow7IuFg60mO1w9iVr9iL']"
7,871.3326411247253,53,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    /// @notice postcondition _owner != address(0) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition _operatorApprovals[_owner][_operator] == approved
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_tokenOwner[_tokenId]) || _from == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0)
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0)
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_z6X8lflAzDleyttPgMjG6JqH', 'thread_tLmd9hawXoyr0Rs91sxHLQwa', 'thread_yVTASNJmpgZjNMEw6W5qUT2Z', 'thread_rBi2XplIZOjYXNAbjIkquorT', 'thread_0OFFLP2jIePDm9ye9tTjw2HE', 'thread_itCS1uVLHv0Fxnhaj9uK0kme', 'thread_l271W86D5dvjlxePj1MWSfUl', 'thread_MiWj9Ub2labqS9ovgfpMQRsj', 'thread_L4x3edwRbp6oSOp4rOlFT1RA']"
8,665.8943800926208,36,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    /// @notice postcondition _owner != address(0)
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == __verifier_old_bool(_operatorApprovals[msg.sender][_operator]) || _approved != __verifier_old_bool(_operatorApprovals[msg.sender][_operator])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_tokenOwner[_tokenId]) || _from == __verifier_old_address(_tokenOwner[_tokenId])
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - ( _from != _to ? 1 : 0 )
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + ( _from != _to ? 1 : 0 )
    /// @notice postcondition _tokenOwner[_tokenId] == __verifier_old_address(_tokenOwner[_tokenId]) || _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_MeMabIYqRnQLm0odQ6MfB49J', 'thread_XKA5Zkx8C345XC0IfKZHook5', 'thread_gQWG7PYqgWhlRLZJCw7RUYdi', 'thread_nF94ovSXWPj8SAiuoDLumwRp', 'thread_JQipCgR1wF2eDoictQaXBCBl', 'thread_V91Y1GfMKHBqlTSFWDgBS3Pb', 'thread_qiEmanG7wkcapnzAnLrGM0IM', 'thread_4u8VGIughLVo6WuIubFMrMsQ', 'thread_5sx3neEVPQrL3Xpk7g58lpfa']"
9,838.7382233142853,50,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition _operatorApprovals[_owner][_operator] == approved
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _to != address(0)
    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0) || _tokenApprovals[_tokenId] == __verifier_old_address(_tokenApprovals[_tokenId])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_ItJZn7xLUyzOoZLtepgC4gNc', 'thread_KtEwB4nBpMKlO2IGX5XU2eij', 'thread_JjdX9tCxM3CkbYi0KCeF12Cx', 'thread_Mu60dMDPUvLQosrCtdF3quQD', 'thread_MaPZMItNxQPChJs1YI5HzixH', 'thread_waXL7GMZ3Mg3qJVMGO8VQNm9', 'thread_EePbyA1cbIP9PwODvb47bJaw', 'thread_km5qW95bTfo8kjwwbEE4uYn3', 'thread_miJcYLO4eAWEW0nuJYcUFjCo']"
10,857.0213475227356,54,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_wsmA7jAArkCFebmakCLBuoAU', 'thread_VtSUi3TSh8Cfr0R8WmNCm0LQ', 'thread_8pqseUkw9isBHNDdphEUwHta', 'thread_p04n3C5mfeoP5jFTrXWytM86', 'thread_3y1hFqvMEn16DA0JdqkBg9mO', 'thread_NXXWZUqnwMcAaM17ga0drmAG', 'thread_5IWKsOUtc6BAKo8I9dOjowWI', 'thread_834YvxTUHbRUFnT9m7TRR07V', 'thread_vAxMUQ3JDkCYNVVbh2IVAK1T']"
