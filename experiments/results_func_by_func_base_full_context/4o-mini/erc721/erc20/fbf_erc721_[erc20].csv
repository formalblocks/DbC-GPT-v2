run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,940.27894282341,59,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition _approved == address(0) || _tokenApprovals[_tokenId] != __verifier_old_address(_tokenApprovals[_tokenId]) || __verifier_old_address(_tokenApprovals[_tokenId]) == _approved
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_nUhPNY7T6das2KsUPHGPYA7D', 'thread_01sbTrEd4N5KgEicuOhvBYME', 'thread_jp1UbmMpkZuxchystYXOPNHc', 'thread_UIRdwb5iRUYgPaxvVatpt8pB', 'thread_NZDaQrNAF4GTgv8QDxxVLICl', 'thread_34zklYX9NfjPFk5cfG1CVR1y', 'thread_ie7yVHTOINqMMbCxJaECJ8rS', 'thread_ufs9vxqfVab7V0MFhhPKoIzp', 'thread_FxpLZW1GK7S6QNZn3PKEXuHN']"
2,686.6164619922638,39,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition _tokenApprovals[_tokenId] != __verifier_old_address(_tokenApprovals[_tokenId]) || _approved == address(0) || _approved == __verifier_old_address(_tokenApprovals[_tokenId])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == _operator && _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved)
    /// @notice postcondition forall (address owner) (_ownedTokensCount[owner] == __verifier_old_uint(_ownedTokensCount[owner]) || owner != msg.sender)
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == __verifier_old_bool(approved) || (approved == (_operator != address(0) && _operator == _owner))
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_7Jh4uRowgDGowlJbGBnMMmB4', 'thread_kwqg0aUvofjuFzQ9dSLUUKAb', 'thread_DymG0aWR4B61u0zaGNeC1lwP', 'thread_8K97S8x8mJ3QHlnVWDXfJaR6', 'thread_j7QW5UfXB8ALj7z2IcyGCQQO', 'thread_3q5Vr3EKN6UjXwqtRcT0LIG9', 'thread_6R8CP9L3CHQE8NCmOgM17iMC', 'thread_SuriI8dFEgdM7OnMBc6r0PXa', 'thread_G8Bk1u923VaRlprwiMFtc9Nq']"
3,654.5643076896667,43,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _ownedTokensCount[_owner] == balance
    /// @notice postcondition _owner != address(0) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition (approved == address(0)) || (_tokenOwner[_tokenId] != address(0))
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == __verifier_old_bool(approved) || (approved == (_operator != address(0) && _operator == _owner))
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_1hWKYreeBSs65iDFwBGUP3PS', 'thread_4nl1SmewE4t2Tj08nvk4VKr7', 'thread_tgfLvB2S1hIbfW1LUYseSbCP', 'thread_4FAR6A26eSPxk4dlHggY9cks', 'thread_2fdKXSxPnaYCWC7L77hoCuUE', 'thread_jscSh3I7XsLS9CAZTDXwgDQs', 'thread_Q3UIl9zipAVLQSVETUu8PvAJ', 'thread_0D87P8PR0TBcbIjzvtuyt8pJ', 'thread_sKskLSzuxS5bCHrNgrkhIxhR']"
4,770.3341100215912,46,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address operator) (_operatorApprovals[msg.sender][operator] == __verifier_old_bool(_operatorApprovals[msg.sender][operator]) || operator == _approved)
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_PLQukJgvk8P05AxgZWVCtG4M', 'thread_a3Bi3b7ACnP9yA6MZ0khwUWv', 'thread_fcszB3TZ1QMnShibEIDN69gO', 'thread_wg6OLPCqW1WskxWpMytUQxjc', 'thread_czFyJbOqZOBuAeiqh61CvWQG', 'thread_l5cu2sEeD42VWL0brH1zEJrs', 'thread_srHtf9UT48LzAETFm4LMObCa', 'thread_EW7BwwnkW6QSNURf6JH5CTuH', 'thread_ZFPXlCsJ9ysliLC4J41sOU9I']"
5,799.9320003986359,46,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == _operator && _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved)
    /// @notice postcondition forall (address owner) (_ownedTokensCount[owner] == __verifier_old_uint(_ownedTokensCount[owner]) || owner != msg.sender)
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == __verifier_old_bool(approved) || approved == (_operatorApprovals[_owner][_operator])
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_nJm3DrZ0elxTo2mKfF3Cxmz2', 'thread_UankAjGacmVP8XOMKrhON95N', 'thread_kgAX0UzGbbhSyyoh4krvsxli', 'thread_MvHPHdJCUFgL56rcnCMs3k0s', 'thread_QVzSxOnKXLOEcuCbw3JahLrQ', 'thread_KTzfTkORw6wuUrzqvZC98Rx9', 'thread_hn1EhZSbDXfO0BuMiR9eVYUD', 'thread_xBl9kSCwuaa9OpP66VJpsWjG', 'thread_0mERichNFvaRQrYazlUvuZJj']"
6,581.781336069107,46,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) (addr == __verifier_old_address(_tokenOwner[_tokenId]) || addr != _approved) || _tokenApprovals[_tokenId] == _approved
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_OkoZS3WZtWv2c1H44xcRtvNg', 'thread_NJI9fuRAbbMtdCjWCQMDVeLx', 'thread_rdX9tt0xZuotOQBGbVdJjhJ3', 'thread_xJvl305V6gXpD9gBOcHS91LO', 'thread_kDNWSNHUmpoVbbuSVQnhaJrJ', 'thread_Kz2Ubqp8Wo0ZjXRG18v0izK7', 'thread_u5Snkq5zMijrQtOLk8nc2ncM', 'thread_TfJRG5lSsVglxtYiLOMQSDEL', 'thread_XF1czO1u7vfdJyxjJYTiAzMb']"
7,577.2359716892242,35,True,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition _approved == address(0) || _tokenApprovals[_tokenId] != __verifier_old_address(_tokenApprovals[_tokenId]) || __verifier_old_address(_tokenApprovals[_tokenId]) == _approved
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition (approved == address(0)) || (_tokenOwner[_tokenId] != address(0))
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved)
    /// @notice postcondition forall (address owner) (owner == msg.sender || _operator == __verifier_old_address(_operator))
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    /// @notice postcondition _tokenOwner[_tokenId] != __verifier_old_address(_from) || _tokenOwner[_tokenId] == _to
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to || _tokenOwner[_tokenId] == __verifier_old_address(_tokenOwner[_tokenId])
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_IcPVPPZLWtSvjNmyQceamzWd', 'thread_VwtKeBI0AR4vZQoZsuW0SS3k', 'thread_ZQdUWZc10TEUXXtoG1sq3mo3', 'thread_szkWFdAL7N9jyvq89gNvHijv', 'thread_zfNtUdxYSFLw66Ojnt3uRnOg', 'thread_LyCDLZ20Wg0xggEj4ZmgkIn3', 'thread_AoAEZN96vNwMAW86xDXDdID0', 'thread_7i4J8MQnX4f6PFCongi5C66l', 'thread_XT1SYeJCyjC3ehGC7QFgoYr3']"
8,588.2672386169434,37,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition __verifier_old_bool(_operatorApprovals[msg.sender][_operator]) != _approved || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == ( _operatorApprovals[_owner][_operator] == true )
    /// @notice postcondition approved == __verifier_old_bool(approved)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_GVeDHwZw8NcxWp5MZc9YxKQx', 'thread_qSX9RdkAndyy6J7E39vfencj', 'thread_uibyhqUUtlCWK4gkFBiSHP9k', 'thread_sf0pKCi56dDAMNzuZKNC24tu', 'thread_QW3O2LrJUQ5O9n5Ecemo0iiK', 'thread_p747y3L078ywhjj6lieYuYXx', 'thread_HdJ0CqrfhI7ujrgNItUtcsOh', 'thread_m5eoxlbpckkxTRSwwPlyUY9l', 'thread_h63glhWeW6MOB34LLhnnj2cl']"
9,690.1836185455322,43,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition _approved == address(0) || _tokenOwner[_tokenId] == msg.sender || _tokenApprovals[_tokenId] == __verifier_old_address(_tokenApprovals[_tokenId]) || _tokenOwner[_tokenId] == __verifier_old_address(_tokenOwner[_tokenId])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _approved != __verifier_old_bool(_approved)
    /// @notice postcondition _approved == true || _approved == false
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    /// @notice postcondition approved == __verifier_old_bool(approved) || approved == (_operatorApprovals[_owner][_operator] == true)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_FMI7ZI0TQExwIgv0C7O9c026', 'thread_XfBccvnu27e4rldMntutKdjt', 'thread_Zz6h8qNmwjV6idca5lSwttG8', 'thread_yLYdI6wY4pGbTGNl0BcqDSCD', 'thread_uVkglov6kSMkUFBjh4qh6whN', 'thread_lvmOmygm92V9ZTQITZil4uys', 'thread_TUsPeLSYxHNvC3uhWjRbEpoB', 'thread_R13nw4CcTJ1wMgXpOK8PHaXw', 'thread_TWwxREU4FpAIiWtCRe0GKw0q']"
10,762.8115248680115,56,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == _owner || balance == __verifier_old_uint(_ownedTokensCount[_owner])
    /// @notice postcondition !(address(0) == _owner) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition _tokenOwner[_tokenId] != address(0) || approved == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == __verifier_old_bool(approved) || approved == (_operator == _operator)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Failed', 'getApproved': 'Verified', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_6udOrwGPRdCbtVvleF8ZpOtG', 'thread_TcmDUu7ND0qimwoHlzlJfHsu', 'thread_sNc0lGbHN3OIRIQJijFMniMB', 'thread_lMk2aODiLhagehePhZ5dSXMd', 'thread_wdui7qttPteWvgX1PG7g8ckw', 'thread_n9dJupS92sRULyx9M6mCPNfh', 'thread_QjDwnErrnfOc35Io8KIXsYMX', 'thread_AIYyJCyIA4FRE21AeV9nNAXk', 'thread_aP1BG0BTkJVdgeDHfeXwnIpK']"
