run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,445.0731432437897,24,True,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    /// @notice postcondition forall (address x) !(x == order.user) || usedNonces[x][order.nonce] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition forall (uint256 fillDeadline) !(msg.sender == address(0) && fillDeadline == order.fillDeadline) || openedOrders[bytes32(fillDeadline)]
    /// @notice postcondition (msg.sender == address(0) && openedOrders[bytes32(uint256(order.fillDeadline))]) || !(msg.sender == address(0))
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition !(usedNonces[order.user][order.nonce]) || order.nonce == __verifier_old_uint(order.nonce)
    /// @notice postcondition resolvedOrder.originChainId == order.originChainId
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition resolvedOrder.originChainId == SUPPORTED_CHAIN_ID
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition filledOrders[orderId] || !__verifier_old_bool(filledOrders[orderId])
    /// @notice postcondition __verifier_old_bool(filledOrders[orderId]) || filledOrders[orderId]
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Verified', 'fill': 'Verified'}",[],"['thread_m6gXnPMs0cIHSAqwk1GwxWKD', 'thread_C5pRTYjhKf5kAcwB5qBsuGrP', 'thread_riJ4kxvTCt9rGzjce8MZZkUh', 'thread_RtNjTQIV2HCJlT8gefwHtgYW', 'thread_T4POxcI5xHi454AOsHEt4Uao']"
2,446.6747863292694,23,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    /// @notice postcondition !(openedOrders[bytes32(order.nonce)] && __verifier_old_bool(openedOrders[bytes32(order.nonce)]))
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition !(0 <= order.fillDeadline && order.fillDeadline < 2) || openedOrders[bytes32(uint256(order.fillDeadline))]
    /// @notice postcondition forall (uint ord) !(0 <= ord && ord < order.fillDeadline) || openedOrders[bytes32(uint256(order.fillDeadline))]
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition !(openedOrders[resolvedOrder.orderId] == true) || openedOrders[resolvedOrder.orderId] == true
    /// @notice postcondition !(usedNonces[order.user][order.nonce] == true) || usedNonces[order.user][order.nonce] == true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition (filledOrders[orderId] && __verifier_old_bool(filledOrders[orderId]) == false) || (filledOrders[orderId] == __verifier_old_bool(filledOrders[orderId]))
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Failed', 'fill': 'Verified'}",[],"['thread_xwEaicflx8OsH3Duxzc8BznF', 'thread_PMqUhfAo4cfUjZc0Ihev3Oyj', 'thread_sVN189tCoMrJzwB9Hmlc4IUZ', 'thread_i4XddciodIF7PvgFG4krOFd4', 'thread_PwskrwoYmhNKO22ktAIdqzUc']"
3,1249.5763800144196,24,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition!(msg.sender == address(0)) || openedOrders[bytes32(uint256(order.fillDeadline))]
    /// @notice postcondition openedOrders[bytes32(uint256(order.fillDeadline))] == true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition !(openedOrders[bytes32(order.nonce)]) || __verifier_old_bool(openedOrders[bytes32(order.nonce)])
    /// @notice postcondition forall (uint x) !(0 <= x && x < order.originChainId) || openedOrders[bytes32(order.nonce)] == __verifier_old_bool(openedOrders[bytes32(order.nonce)])
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition !filledOrders[orderId] && __verifier_old_bool(filledOrders[orderId]) || filledOrders[orderId]
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Failed', 'fill': 'Verified'}",[],"['thread_cY2wJbDrCjEOgPMx13YXpjDA', 'thread_uODoiOwVBLyjQ3BMt6pnJs2B', 'thread_Wk6nIt8QsLfDpsNGLxUwfI2E', 'thread_lAI8NHMOqj5oDBrGveIXRvIz', 'thread_JUvOJPJOqSjVvahSqDfegaH7']"
4,165.4885060787201,9,True,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition openedOrders[bytes32(uint256(order.fillDeadline))] == true
    /// @notice postcondition forall (address addr) !(addr == msg.sender) || usedNonces[msg.sender][order.fillDeadline] == __verifier_old_bool(usedNonces[msg.sender][order.fillDeadline])
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition resolvedOrder.user == order.user
    /// @notice postcondition resolvedOrder.originChainId == SUPPORTED_CHAIN_ID
    /// @notice postcondition resolvedOrder.openDeadline == order.openDeadline
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    /// @notice postcondition resolvedOrder.orderId == bytes32(order.nonce)
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition resolvedOrder.originChainId == SUPPORTED_CHAIN_ID
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition !(filledOrders[orderId] == __verifier_old_bool(filledOrders[orderId])) || filledOrders[orderId]
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Verified', 'fill': 'Verified'}",[],"['thread_bo9jvipJ3N6ydVB9r3Sj2ra7', 'thread_75NZA2kBSLaSejii0z0S5sUH', 'thread_40VuTv52KjNWg8xWqpE9WgeE', 'thread_u6pkAkodUl6f07PkUsQph0o1', 'thread_0FBkZzm2Lt50JEPVgkaYz8DF']"
5,414.40478324890137,25,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition resolvedOrder.originChainId == order.originChainId
    /// @notice postcondition resolvedOrder.user == order.user
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition !(openedOrders[bytes32(uint256(order.fillDeadline))]) || (openedOrders[bytes32(uint256(order.fillDeadline))] &&  __verifier_old_bool(openedOrders[bytes32(uint256(order.fillDeadline))]))
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition filledOrders[orderId] == true
    /// @notice postcondition !(filledOrders[orderId]) || filledOrders[orderId] != __verifier_old_bool(filledOrders[orderId])
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Failed', 'resolveFor': 'Verified', 'resolve': 'Verified', 'fill': 'Verified'}",[],"['thread_EtFJOc0RkAAOwKRpNlC18NOx', 'thread_yYca83xaK4tr27UJ15jWWf67', 'thread_daD48ERy9Nm1Tah4OZ86tJAP', 'thread_HpueFIAIDpRTuHmdduaOZEdi', 'thread_nMerHUqi51V0NUkgwunLEeLc']"
6,339.53867840766907,15,True,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition usedNonces[order.user][order.nonce]  == true
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == !(__verifier_old_bool(openedOrders[bytes32(order.nonce)]) )
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition openedOrders[bytes32(uint256(order.fillDeadline))] == true
    /// @notice postcondition forall (address x) (x != msg.sender && usedNonces[x][order.fillDeadline] == __verifier_old_bool(usedNonces[x][order.fillDeadline])) || (msg.sender == x && usedNonces[msg.sender][order.fillDeadline] == true) || msg.sender == x
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition resolvedOrder.originChainId == order.originChainId
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition resolvedOrder.originChainId == SUPPORTED_CHAIN_ID
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    /// @notice postcondition resolvedOrder.orderId == bytes32(uint256(order.fillDeadline))
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition filledOrders[orderId] == true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Verified', 'fill': 'Verified'}",[],"['thread_gPDh3AUObIQfJZZQVBVwR144', 'thread_MgikLsnUPjmq3dgqK6GJtvi6', 'thread_6yaJUoq9ttwF5VlUI0HQOez7', 'thread_F7vzEap6bwyCMvt56y9zNHmr', 'thread_u2nmcG1i8EfLeQPYGQW8EDhH']"
7,516.1967573165894,26,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    /// @notice postcondition __verifier_old_bool(openedOrders[bytes32(order.nonce)]) || openedOrders[bytes32(order.nonce)]
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition resolvedOrder.user == order.user
    /// @notice postcondition resolvedOrder.originChainId == order.originChainId
    /// @notice postcondition resolvedOrder.openDeadline == order.openDeadline
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    /// @notice postcondition resolvedOrder.orderId == bytes32(order.nonce)
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition !(filledOrders[orderId] && __verifier_old_bool(filledOrders[orderId]))
    /// @notice postcondition filledOrders[orderId]
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Failed', 'resolveFor': 'Verified', 'resolve': 'Failed', 'fill': 'Verified'}",[],"['thread_8DhqQYR3Hi9kpApfpVCrFzfR', 'thread_CvuVPe0USBlxJZKN5xYwFeOZ', 'thread_9DQTW3Lf1rqwJybrvtxquu8t', 'thread_PawFWsOcQK7pN4uwxLn6kuMh', 'thread_cXU0ODAcrHoNU6I5qYt5G26B']"
8,466.39869809150696,33,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition resolvedOrder.originChainId == order.originChainId
    /// @notice postcondition resolvedOrder.user == order.user
    /// @notice postcondition resolvedOrder.openDeadline == order.openDeadline
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Failed', 'resolveFor': 'Verified', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_WONptP8Vs1SXqUnmqBFG3KGo', 'thread_xlBqrBZdptddwcFcdIwegRIr', 'thread_fmAtaY04ibzoqTzIJ05HjT9i', 'thread_4MHyqQbdz1je9AhUgUzo05pg', 'thread_PwaYmSlpoNlnmJtDb1TGbMv3']"
9,558.4710054397583,25,False,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    /// @notice postcondition usedNonces[order.user][order.nonce] == true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition openedOrders[bytes32(uint256(order.fillDeadline))] == true
    /// @notice postcondition forall (uint x) !(0 <= x && x < order.orderData.length) || openedOrders[bytes32(uint256(order.fillDeadline))]
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition filledOrders[orderId] == true || filledOrders[orderId] == __verifier_old_bool(filledOrders[orderId])
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Verified'}",[],"['thread_RwXXaARVrK3VD4AH8wzktjxg', 'thread_guTtW59wsqHRflCQMpFdPA0Y', 'thread_FdSQDya9UgPoU3lhWFiSJSH6', 'thread_VvyeV2Rn16Cecyec0JijCOqq', 'thread_zEXtBrnrInVIsWBgFCxUlOyj']"
10,186.64097118377686,8,True,"pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition openedOrders[bytes32(order.nonce)] == true
    /// @notice postcondition forall (address a) !(a == order.user && usedNonces[a][order.nonce] == true) || (usedNonces[a][order.nonce] == __verifier_old_bool(usedNonces[a][order.nonce]) && !usedNonces[a][order.nonce]) || usedNonces[a][order.nonce] != __verifier_old_bool(usedNonces[a][order.nonce])
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition openedOrders[bytes32(uint256(order.fillDeadline))]
    /// @notice postcondition !(openedOrders[bytes32(uint256(order.fillDeadline))] &&  __verifier_old_bool(openedOrders[bytes32(uint256(order.fillDeadline))]) )
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition (resolvedOrder.user == order.user) && (resolvedOrder.originChainId == order.originChainId) && (resolvedOrder.openDeadline == order.openDeadline) && (resolvedOrder.fillDeadline == order.fillDeadline)
    /// @notice postcondition resolvedOrder.orderId == bytes32(order.nonce)
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition resolvedOrder.originChainId == SUPPORTED_CHAIN_ID
    /// @notice postcondition resolvedOrder.fillDeadline == order.fillDeadline
    /// @notice postcondition resolvedOrder.user == msg.sender
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition !(filledOrders[orderId] && __verifier_old_bool(filledOrders[orderId]))
    /// @notice postcondition filledOrders[orderId]
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Verified', 'open': 'Verified', 'resolveFor': 'Verified', 'resolve': 'Verified', 'fill': 'Verified'}",[],"['thread_41ksM1Hx5ABOKhiqEVLBx3Ij', 'thread_uBhD80o41u1Qx5OLQRCIrpNI', 'thread_DcPdHgAMXX7aSMdMZkWeAzhg', 'thread_FAwM2Pv6nnCuLBt2WEPGFj22', 'thread_iUtmqI0PLc6sZ3PXjHsAmkEj']"
