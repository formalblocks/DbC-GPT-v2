run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,441.6101624965668,38,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition _owner == __verifier_old_address(_owner) || balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _owner == _tokenOwner[_tokenId]
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) + 1 == _ownedTokensCount[_to] || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_3YhCIJMqne0i6vhWEWQZY7fk', 'thread_ClhQ1XKUpFditleOH5EweSTz', 'thread_QrsiQPfneYtCwQQaOehl9ksI', 'thread_Dl2ZvVqrTPPSU2iJQH23jTGW', 'thread_mPtAnU2KsetYgPXowBuJvboL', 'thread_jijaqMPfZkGmyUXll1npNn6f', 'thread_wDp1vpVyxQnGi66OtSL2XG6O', 'thread_wwl1Gru9DmiYk3Nkt6yLCXko', 'thread_xXNnB3IAqNTp3XNWIuF1fNTK']"
2,312.16875314712524,27,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition _owner == __verifier_old_address(_owner) || balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition forall (uint i) !(0 <= i && i < _tokenId) || _tokenApprovals[i] == __verifier_old_address(_tokenApprovals[i])
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator == msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_qw5k3ZNXu31qkkOKhiHj7CTK', 'thread_CJaN9Lk3G4GU7CT5NgtohAPf', 'thread_keNJoXJZK2xe3SDonrsEwhLA', 'thread_PfgZJTvcdYdvgVEPzqTqwATw', 'thread_QM3ecvEmcV5UFqLvONZgFIeg', 'thread_RnJZsmvAdpwsnXsenmHpXK5d', 'thread_OPd3QAb4hl29tzSLPmSyi5yE', 'thread_GDAVoB1quEbRcyXfCeXxFwjE', 'thread_eP1x7LmJ9anObohrbwctVmal']"
3,328.56907749176025,29,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || approved == _tokenApprovals[_tokenId]
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || approved != address(0) || _tokenApprovals[_tokenId] == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator != __verifier_old_address(_operator) && _operator != msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved) && _operator == msg.sender
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_2DDheKHWYPLTLR9WsdLCTn58', 'thread_LS8TVOypWX031R9UATYxmuQN', 'thread_AAPxvTNi4ppjG8mloRN01q0l', 'thread_aGpUgrh8Mh0iEDK1cPhT9fj0', 'thread_LPAlJqEmPflt5Sn5HN7famCa', 'thread_4umMSh4GdvWyuF02IqdaGOJA', 'thread_9mXsF60otpjvCUVrGreVoMdL', 'thread_Zamcrj7OUYv57dIUygrdDJMs', 'thread_DvZLjONJuwjRDuREpk6C4VLr']"
4,482.53376722335815,37,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == address(0) || balance == _ownedTokensCount[_owner]
    /// @notice postcondition _owner != address(0) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0) || _tokenId != _tokenId
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenOwner[_tokenId])) || _tokenOwner[_tokenId] == __verifier_old_address(_tokenOwner[_tokenId])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator == msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] || __verifier_old_uint(_ownedTokensCount[_to]) + 1 == _ownedTokensCount[_to]
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_nVFjCeZYfFiawmFQL1nOD4i1', 'thread_794aCWlvPeyyj4C7qq55Fmrp', 'thread_pyoLnf6HH85p3jONwtDjYoSV', 'thread_vzJUJxGLY2FQJEGHzpdzM076', 'thread_5XADgv56DEQpVg2lGlyPiLta', 'thread_mffG4oJ5vD6jg1fzQuuHzhnQ', 'thread_pCMMfccBLJmLOgqvWYCXBDtA', 'thread_NmMH9Y8FpTtE25BuiTwL0MMa', 'thread_DsTdXqL7JTKwBv0hKh3yoRIv']"
5,333.6548092365265,28,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0) || _tokenId != _tokenId
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator != __verifier_old_address(_operator) && _operator != msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved) && _operator == msg.sender
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] || __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] || (_from != _to && (__verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 && __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1))
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_eO0usFUQOCWOYppfVyVWnbPS', 'thread_IIVfggf9NZBhTkoFgRu1ryQ1', 'thread_Z4FuY26LWR1VFvcm8w4auzZP', 'thread_uaXnwLxdbub4cIlojE75o2On', 'thread_mfOQKCgxUqHIxJ6HbXqqyHP8', 'thread_EuMFb2HpIvi1iWwtytrCG6qn', 'thread_xyQhfPGyfo9MB8Fm932oqfCV', 'thread_LgIYWSKo7NW7bTjwamiR5XW0', 'thread_NIjLO3DzbaZZtv6UrC41Quhn']"
6,347.4155316352844,30,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == address(0) || balance == _ownedTokensCount[_owner]
    /// @notice postcondition _owner != address(0) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || approved == _tokenApprovals[_tokenId]
    /// @notice postcondition forall (uint x) !(0 <= _tokenId && _tokenId < 2**256 - 1) || !(x == _tokenId) || approved == _tokenApprovals[x]
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator == msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_Ai05MO2dg6vCM4hGQvlDheI9', 'thread_naYWINo9UJI8Ajk9RgzJZYr3', 'thread_ro7w9dpNqNHLKS003MLltqGi', 'thread_T8uxapKYDLVycMlo4nnb4mCV', 'thread_CdS0LXLsSMUjXELs2Z3LzWyI', 'thread_me7Yql25CGPaNHTqWtodXRTp', 'thread_uTqk912ulRZ3P7xxzDmJNdJ7', 'thread_yCi0IFQ5BoRFDBMVAngeE4Lg', 'thread_oeg4kd0ljCgL5B8ohJH2Kv4f']"
7,513.2108006477356,45,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner == address(0) || balance == _ownedTokensCount[_owner]
    /// @notice postcondition _owner != address(0) || balance == 0
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator != __verifier_old_address(_operator) && _operator != msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved) && _operator == msg.sender
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Failed', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_6xK5axFFbi1yhALJ8Z5Jd7im', 'thread_KRDswQe4oUjB3zEOFOShVTf4', 'thread_Y8Ch7pr5D4BQ2DbILKoglzJT', 'thread_8bTFuT6fBYVgkAjuDXPS1T4e', 'thread_HaHAjnfyPRxMi5Vbm4268eEv', 'thread_9XYENm7ex5T1jbZ6K8GmtHQd', 'thread_MWg9xZRESVD07XdtbtZOnPhT', 'thread_IgYj1uG0hndYHThu5GQbuMw1', 'thread_KJUl38Wcfc8C3zDSGRwK761Y']"
8,329.6167812347412,27,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition _owner != address(0) || _tokenId != _tokenId
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenApprovals[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator != __verifier_old_address(_operator) && _operator != msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved) && _operator == msg.sender
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_syO51VpA25aZ8VRWcoxM74LA', 'thread_gVm9gTjtp7HHZFSPZNfsegxz', 'thread_fd0XNHv7ANiWW7LnXLdTz1p6', 'thread_wTOYGV1Q4fWyDgHjod2khOqE', 'thread_6wIvPsGcKBvDoougikqZlr1p', 'thread_CL06bmdU8WVwbYcpGA9BlRhh', 'thread_Nha9GGXzHsINHSkJORgMkoQ3', 'thread_3rdrVD1Zb1fhD6nXWgrmDnmU', 'thread_MvKrajD6ryHv7wNsLUFjOIZ3']"
9,419.68293166160583,22,True,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _tokenOwner[_tokenId] == _owner
    /// @notice postcondition !(0 <= _tokenId) || (_owner != address(0))
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == __verifier_old_address(_tokenApprovals[_tokenId]) && _tokenOwner[_tokenId] == addr) || _tokenApprovals[_tokenId] != addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || approved == _tokenApprovals[_tokenId]
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || approved != address(0) || _tokenApprovals[_tokenId] == address(0)
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator != __verifier_old_address(_operator) && _operator != msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _approved != __verifier_old_bool(_approved) && _operator == msg.sender
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_s9vbaJUqN0xnFKz312C6V4cF', 'thread_QW3CsICCftYA6Qx5AybySfLG', 'thread_IR2NmaCH70bB6GvEM1aD2hT4', 'thread_m7k8NcLFTtBC8GvlW5W6LL6W', 'thread_jFHjb2YLrQ81G42OXIGOStuY', 'thread_mtuOOBzm8wxRXjZFaMN9hDZS', 'thread_t9AsbKXdZqG4WWfTO9J7Ak8O', 'thread_E3DlE52i3JGWqfRqGFuGJhjT', 'thread_y58miLIM54g4F0A5OFZElM41']"
10,272.02442717552185,20,True,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition !(0 < _tokenId) || _owner == _tokenOwner[_tokenId]
    /// @notice postcondition _owner == address(0) || _tokenOwner[_tokenId] == _owner
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) !(addr == _approved && addr == __verifier_old_address(_tokenOwner[_tokenId])) || _tokenApprovals[_tokenId] == addr
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition _tokenApprovals[_tokenId] == approved
    /// @notice postcondition forall (uint i) !(0 <= i && i < _tokenId) || _tokenApprovals[i] == __verifier_old_address(_tokenApprovals[i])
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator == __verifier_old_address(_operator) || _operator == msg.sender
    /// @notice postcondition _approved == __verifier_old_bool(_approved) || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] + 1 || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from])
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] - 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] || __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] || (_ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1 && _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1)
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Verified', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Verified'}",[],"['thread_6eZKDTMe3fpzyCDuMv0BQ7KR', 'thread_2prwyXlOduK44WwHuLJOU8YI', 'thread_OXgsIvmJhw6G8ONuZYiOIyVs', 'thread_HdXdfz099tyBgS8m0VK5kImO', 'thread_kBadFBSlYJ4TcTZuPNjreZGX', 'thread_6bqAUpyoxaxEStgJc0dXomZL', 'thread_6gcXmHAJcXQcUCmguOVJ18yB', 'thread_VfTdj23TCx6sR1yaZFyY7wNp', 'thread_ckaBo10GYb3DhefJBqayGw2Q']"
