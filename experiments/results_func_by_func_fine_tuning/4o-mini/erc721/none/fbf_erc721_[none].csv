run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,668.652224779129,50,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition _owner == _tokenOwner[_tokenId]
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address addr) (addr == _approved || addr != __verifier_old_address(_approved) || _tokenApprovals[_tokenId] == __verifier_old_address(_approved))
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == (_operatorApprovals[_owner][_operator] == true)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_address(_tokenOwner[_tokenId]) == _from
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_vU00xCjVpgMSo4BWViojMoUr', 'thread_21ZduhnPhIiTsmRpTWCOYIDh', 'thread_JbIsIJbuODqvuAHUFFLvMDbm', 'thread_90eAWbEJ3OUor4tJA4LN7MsQ', 'thread_ie0hO9xx7KmaDL3np6N9JHLl', 'thread_Wt3L3gEi2adqBcEaK2wAOJyR', 'thread_NEJZULKpD8Yc9TLrs25W9iKG', 'thread_dh93OFcBW6kD7e0qJtT1Hffi', 'thread_7NJMIHUfC6n13XPe4XZxP884']"
2,752.3388020992279,59,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address operator) _operatorApprovals[__verifier_old_address(msg.sender)][operator] == _operatorApprovals[msg.sender][operator]
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _approved != __verifier_old_bool(_approved) || _operator == __verifier_old_address(_operator)
    /// @notice postcondition _operator == address(0) || _approved == __verifier_old_bool(_approved)
    /// @notice postcondition _ownedTokensCount[msg.sender] == __verifier_old_uint(_ownedTokensCount[msg.sender])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_KCxwX94oOr21PTuSFvpHakjq', 'thread_ZgCZyCBl1zVSEYDyfALwZOu8', 'thread_o5e1Hc9gD74mh7uH9obqSOhM', 'thread_SIGRmI8ju4d35jdy2k3fIvQa', 'thread_saJqYYZyLzj8TgXBWCMvAEOa', 'thread_dowBJa2rDj5CDnyza7xfBSXA', 'thread_X1SMm3bINGeGt3todKZpGUSk', 'thread_RKsRWqTihZ9wCL5KIEJCOpsC', 'thread_A2zfHiK7IHU6vB7V1YrvLUhm']"
3,629.5719437599182,57,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address operator) (_operatorApprovals[__verifier_old_address(msg.sender)][operator] == _operatorApprovals[msg.sender][operator])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == __verifier_old_bool(_operatorApprovals[_owner][_operator]) || _owner == _operator
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1 || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to])
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_LymSbYviTFmUheyHPFdtV6PO', 'thread_2kR73CcH53arLzY6KHrLLSkK', 'thread_EQTM51y3z0tspB1JMmrATzMM', 'thread_LdPXYvv3tOJu9uHPWRK225BI', 'thread_n6yyZfgDECD9rtEzhcBgQtql', 'thread_fAOvYgFbAXamsG9nzKStprKe', 'thread_ju1zZ57wmB0WnmcvhhrotShE', 'thread_jy1Jic1zwkUIbbbKCHs9MvY0', 'thread_UWDZ18VdmdNTmOvA2pz9uZ0R']"
4,760.1547050476074,55,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition !(0 < _tokenId) || _owner == _tokenOwner[_tokenId]
    /// @notice postcondition !(0 < _tokenId) || _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address operator) (_operatorApprovals[__verifier_old_address(msg.sender)][operator] == _operatorApprovals[msg.sender][operator])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_ILRLmJGHJm5VYbGaFfXlZhsn', 'thread_ygZsaBnB0PvNIUxqAOpkrAVL', 'thread_7PO0R20LgrofczJCtvcA3Z3c', 'thread_8rVV9YDH90dGgKibnnRj8bxw', 'thread_x9O0fnLETHYa7ziUljOvJIJV', 'thread_NrU8uPRoijrD5M0miybnYPrH', 'thread_Yua35OmK32bPeyGWI8pglCCI', 'thread_FuaGZgfryCKVEE0cSwIvtCgh', 'thread_Uh8TygiTeyBbKiS1wn48dQir']"
5,959.3356575965881,65,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition forall (address operator) (_operatorApprovals[__verifier_old_address(msg.sender)][operator] == _operatorApprovals[msg.sender][operator])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator != address(0) || __verifier_old_bool(_approved) == _approved
    /// @notice postcondition _operator != address(0) || _operatorApprovals[msg.sender][_operator] == _approved
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Failed', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_4HynshM0aJSdSbdwIH75KteB', 'thread_MOH8O0jPoApdm6FJtynUtpC9', 'thread_W0JDDCVO9Io2NXoWTgVA1CHt', 'thread_UNSrZEpgceFZNFE8S4TNlTZg', 'thread_tqUcVzYiOO8io0dn9fsoZkO7', 'thread_wHZ44k1a5y17KXxOAAQiba0O', 'thread_RQd4LpfeCVTpTnK7oxCRkBES', 'thread_9WsvAIiCpuLnOQitXFt7QmHf', 'thread_m1h2epB9jWDZMlPKk3kaRyFl']"
6,926.4710741043091,76,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) == address(0) || _tokenApprovals[_tokenId] != __verifier_old_address(_tokenApprovals[_tokenId]) || _approved == __verifier_old_address(_tokenApprovals[_tokenId])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    /// @notice postcondition _operator == address(0) || approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_oTql5sgdoCGtbmtI3bCHX0Jq', 'thread_ZwU51K2Glihrv1vkHrdlToq6', 'thread_pMlV2T8F2RtNZJ9X1w8SPQ5J', 'thread_Unzv6D0Wrh9ONLhackZ2PD8j', 'thread_5oriJvo9zQfqibrn43OEamoA', 'thread_74O4iFqtLTajwdLsmdEsJQhR', 'thread_3DpisAHhdOoLzCEpHCn9Km4T', 'thread_glr7KqZlyTURBHIdvvc1c1jK', 'thread_0SsN82zOaWFBU3xSBtEfd7Ij']"
7,737.6982328891754,55,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _owner == _tokenOwner[_tokenId]
    /// @notice postcondition !(0 <= _tokenId && _tokenId < 2**256 - 1) || _owner != address(0)
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition _tokenApprovals[_tokenId] != address(0) || _approved == address(0)
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition _operator != address(0) || _operatorApprovals[msg.sender][_operator] == _approved
    /// @notice postcondition _operator != address(0) || _operatorApprovals[msg.sender][_operator] != __verifier_old_bool(_operatorApprovals[msg.sender][_operator]) || _approved == __verifier_old_bool(_approved)
    /// @notice postcondition _operator != address(0) || _ownedTokensCount[msg.sender] == __verifier_old_uint(_ownedTokensCount[msg.sender])
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == (_operatorApprovals[_owner][_operator] == true)
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Verified', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Verified', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_IPXTxr7KolOTrreLQy6aeQIH', 'thread_r4HHHSgfEBF52S77BPeMCJE8', 'thread_07jyWvRjLDidtTLbm7T3tEeJ', 'thread_wSpUC0fPS1CMk9uGNLeLXJSu', 'thread_4248RISnoL0PO037dogWlYyl', 'thread_X5b8fNMWOZ6dHo4nGcSAxRVT', 'thread_Ihop6oibIIRRXPeNNA8dBBtA', 'thread_j2QsX0PyKgRqcg83EumusMdY', 'thread_NJeZFVp6HiYUDtcf8lI307Cw']"
8,798.8681490421295,64,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) != _approved || _tokenApprovals[_tokenId] == _approved
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_3dUJ9i4scJpfO8th1TEuDfv2', 'thread_hKWUrnYFzPjPBTZ1N5ZZLxY6', 'thread_sdvHMKtFFSc1iJgffv0MkSKo', 'thread_jZFFHHE9j1hnKivtWZYblFVO', 'thread_MCDd7QvID0kT90NVXRhVn0Hv', 'thread_ORKAPOYRMLA2WtZqe755dgTE', 'thread_OtfiX2WqWVSXY6Akfw1yVy4K', 'thread_ZF9mgKpO5xTf5KeOLlhyBKec', 'thread_Z8gIABNn1qB6EKQlbZimPkKN']"
9,918.6561553478241,81,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition true
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition true
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition true
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Failed', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Failed', 'transferFrom': 'Failed', 'safeTransferFrom': 'Failed'}",[],"['thread_twB4ffvfnayiRNhIeBz6NFqP', 'thread_gdwRLVOi32t23kTpONJTgMvM', 'thread_LSUiEasovtFb5Hxj6ALrABr8', 'thread_1ZOpuEhcZJJG2cHPkSMCUvCa', 'thread_KUGn1NbWqJhPaVzUxCRNVAXH', 'thread_9KNRZoUXN25944GaXDzNDLhi', 'thread_7kPRgn54WjjiVrZDIAhCGPp2', 'thread_q84j1mZ9lPSmo1Fh7YMTv3VR', 'thread_T1FIxqBH4A450aW4WWY5ci1w']"
10,848.4235196113586,66,False,"pragma solidity >=0.5.0;

contract ERC721 {

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;
    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;

    mapping (uint256 => address) private _tokenOwner;
    mapping (uint256 => address) private _tokenApprovals;
    mapping (address => uint256) private _ownedTokensCount;
    mapping (address => mapping (address => bool)) private _operatorApprovals;

    // Functions
    /// @notice postcondition _owner != address(0) || balance == 0
    /// @notice postcondition balance == _ownedTokensCount[_owner]
    function balanceOf(address _owner) external view returns (uint256 balance);

    /// @notice postcondition true
    function ownerOf(uint256 _tokenId) external view returns (address _owner);

    /// @notice postcondition _tokenApprovals[_tokenId] == _approved
    /// @notice postcondition __verifier_old_address(_tokenApprovals[_tokenId]) == address(0) || _tokenApprovals[_tokenId] != __verifier_old_address(_tokenApprovals[_tokenId]) || _approved == __verifier_old_address(_tokenApprovals[_tokenId])
    function approve(address _approved, uint256 _tokenId) external;

    /// @notice postcondition true
    function getApproved(uint256 _tokenId) external view returns (address approved);

    /// @notice postcondition true
    function setApprovalForAll(address _operator, bool _approved) external;

    /// @notice postcondition approved == _operatorApprovals[_owner][_operator]
    /// @notice postcondition _operator == address(0) || approved == true || approved == false
    function isApprovedForAll(address _owner, address _operator) external view returns (bool);

    /// @notice postcondition _tokenOwner[_tokenId] == _to
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_from]) == _ownedTokensCount[_from] || _ownedTokensCount[_from] == __verifier_old_uint(_ownedTokensCount[_from]) - 1
    /// @notice postcondition __verifier_old_uint(_ownedTokensCount[_to]) == _ownedTokensCount[_to] || _ownedTokensCount[_to] == __verifier_old_uint(_ownedTokensCount[_to]) + 1
    /// @notice postcondition _tokenApprovals[_tokenId] == address(0)
    /// @notice postcondition _to != address(0)
    function transferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;

    /// @notice postcondition true
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external;

}
","{'balanceOf': 'Verified', 'ownerOf': 'Failed', 'approve': 'Verified', 'getApproved': 'Failed', 'setApprovalForAll': 'Failed', 'isApprovedForAll': 'Verified', 'transferFrom': 'Verified', 'safeTransferFrom': 'Failed'}",[],"['thread_RZUJEQmS0rD3qamqR86ISpgK', 'thread_ymWb3poqhiGpcy6EauUhLsFb', 'thread_Z2hm3Hl4f0ep6Ns2w92un9cd', 'thread_dYE8QTOE8hrtdy9tGp75MoIU', 'thread_orGCd15vGi14DSzwlCioHmKt', 'thread_v7MAee8nG6NBYS1MZ0Oa6Chx', 'thread_WfozYsaA1dA6G5WoYYyZzf6a', 'thread_3HrHV5aYdgxXDfkiOECgw1wQ', 'thread_gD7wuU6yYp0KEUZsnc8MgK05']"
