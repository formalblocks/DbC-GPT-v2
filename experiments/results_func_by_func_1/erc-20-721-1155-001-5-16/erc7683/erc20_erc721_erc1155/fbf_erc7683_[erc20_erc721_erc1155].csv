run,time_taken,iterations,verified,annotated_contract,function_status,status,threads
1,520.1251339912415,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_E6HfN2Gv0c2qvysUZx7wsET5', 'thread_vcTNRt1Wjq6Xxvm2nNrYJtZR', 'thread_Xx0Flv46a9q8vSr5zJ3ZavPt', 'thread_Upqh70Xrqz2N23gQx2p3OLwH', 'thread_CMz2ZUvYfLJyvSXD5rZEwsQF']"
2,604.8855316638947,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_nXpyMWajErxIwGekwbtfToH2', 'thread_5ABDnTvH9GsVC2yVILmac9tq', 'thread_gsq6P14g7ebfkoGAAnLlO0hb', 'thread_7bccOeeHNa5dqwlky2ceHttp', 'thread_eWVtObYiLVkeZ3VTx1GHBaX4']"
3,20247.404900550842,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_PdN7cUCn4k0P77b8KbNdB1zp', 'thread_aSWFILjjTAWmix5CgDlGksx3', 'thread_3K9FDeNfujgQUOxISvg098av', 'thread_HhR3oFA8GDnKo0Fz3PS492jl', 'thread_HhPoniciqKrPTFFPkbIzhK2u']"
4,7273.892195224762,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_x1PJ2Z2R0ldgPs1sMGWT1n8m', 'thread_ms44XksUZYTXPWQJzss1Dsv4', 'thread_SrOJIRBgeRElzPXjWIiBAlV2', 'thread_EFsCTf4vQyTxhkjEw4EiC9C5', 'thread_HIslsi0cv1wPdFF6g6vjOcw0']"
5,572.6050612926483,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_EkpsIjPvvoTBISu8asXiWvp6', 'thread_gtvMHKDejl77gz35lGpLNsmu', 'thread_prUABYjspTK5lPoYOQOhQZYv', 'thread_JMWNZF13T0FlGyuGAdbyIWkP', 'thread_wBpZdgLR7qKvZGrE5IpTg3dr']"
6,498.4690103530884,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_r9Kr0wCWvPPTpVSP7GVTLAPq', 'thread_S0YawU5rOxF5d5iicjqXC5YR', 'thread_LKCf0uXLaJnXKEWfQsV4BJYJ', 'thread_AkTEeOxX9YfGEPP0juCx2z32', 'thread_n4Z9aACXOQSyEUmwXlQTP5bi']"
7,506.6367585659027,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_hbrn7Ujbfx1I6VVDjuibEOmU', 'thread_ybYVuwTIy77wtStCeCNj9mQJ', 'thread_AXBXhPxFCnoOMp7wIpcOPMtf', 'thread_WTPZvsRpcQeqFO1IAEvzXk8F', 'thread_ZASm6CK8EfanasqYOhm4G9WW']"
8,500.88263607025146,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_pKVBC1ZVH4Vj5WQxydEdUv2e', 'thread_cEmR6wPZ85rq8zT9DDTxi1c0', 'thread_eMYaDpWGsgTZgNgYJwgRpC3x', 'thread_kvHtFINEM2a8DrciktiTZMgq', 'thread_fGRrBaKB8CBmjV57dJHGIXJZ']"
9,528.5366990566254,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_vb3Qc9LAdLvFeD5tFAOKPG15', 'thread_A76HO9uxE0UiVfqyWG4U2Slv', 'thread_psk0K4RjfQ61JwP4gd0etPAA', 'thread_V5f0LI0NvUlrjSHcZ4afOgBg', 'thread_yYAiVwmKHZDUlAvqIYYg45BX']"
10,506.7812747955322,50,False,"pragma solidity ^0.5.0;

library ERC7683Types {
    struct GaslessCrossChainOrder {
        address originSettler;
        address user;
        uint256 nonce;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct OnchainCrossChainOrder {
        uint32 fillDeadline;
        bytes32 orderDataType;
        bytes orderData;
    }

    struct ResolvedCrossChainOrder {
        address user;
        uint256 originChainId;
        uint32 openDeadline;
        uint32 fillDeadline;
        bytes32 orderId;
        Output[] maxSpent;
        Output[] minReceived;
        FillInstruction[] fillInstructions;
    }

    struct Output {
        bytes32 token;
        uint256 amount;
        bytes32 recipient;
        uint256 chainId;
    }

    struct FillInstruction {
        uint64 destinationChainId;
        bytes32 destinationSettler;
        bytes originData;
    }
}

contract ERC7683 {

    // Events
    event Open(bytes32 indexed orderId, ERC7683Types.ResolvedCrossChainOrder resolvedOrder);

    // State Variables
    mapping(address => mapping(uint256 => bool)) public usedNonces;
    mapping(bytes32 => bool) public openedOrders;
    mapping(bytes32 => bool) public filledOrders;

    // Functions
    /// @notice postcondition true
    function openFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata signature,
        bytes calldata originFillerData) external;

    /// @notice postcondition true
    function open(ERC7683Types.OnchainCrossChainOrder calldata order) external;

    /// @notice postcondition true
    function resolveFor(ERC7683Types.GaslessCrossChainOrder calldata order,
        bytes calldata originFillerData) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function resolve(ERC7683Types.OnchainCrossChainOrder calldata order) external view returns (ERC7683Types.ResolvedCrossChainOrder memory resolvedOrder);

    /// @notice postcondition true
    function fill(bytes32 orderId,
        bytes calldata originData,
        bytes calldata fillerData) external;

}
","{'openFor': 'Failed', 'open': 'Failed', 'resolveFor': 'Failed', 'resolve': 'Failed', 'fill': 'Failed'}",[],"['thread_RZAOQ7yaShXMbkjM8Jl8X9ZC', 'thread_SYqEDYT5aXFhFdoS1GexZxTF', 'thread_BDAIYBrpnZ64EQSuafuViiF8', 'thread_K2RX3KKcgOWDJ9aiXADvjhbL', 'thread_IwOBDaR8wr8cWkrlvIMrC6cz']"
